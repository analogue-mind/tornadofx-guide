# Вступление

Пользовательские интерфейсы становятся критически важными для успеха потребительских и бизнес приложений. С подъемом веб приложений и потребительских мобильных приложений, пользователи бизнеса быстро подняли планку качества к корпоративным приложениям. Они хотят насыщенные, многофункциональные пользовательские интерфейсы, которые будут однозначно понятны и интуитивны при навигации по комплексным экранам. Наиболее важно, они хотят, чтобы приложение быстро адаптировалось к изменениям в бизнесе на частой основе. Для разработчика это означает, что приложение должно быть не только поддерживаемым, но также развиваемым. TornadoFX стремится помочь в достижении этих целей и значительно упрощает разработку пользовательских интерфейсов JavaFX.

Пока большая часть корпоративного мира IT продвигает HTML5 и облачные приложения, многие компании продолжают использовать фреймворки для построения пользовательских интерфейсов, такие как JavaFX. Хотя они не масштабируются на большую аудиторию так же легко, как веб приложения, JavaFX хорошо работает для "внутренних" бизнес приложений. Высокая производительность с большим набором данных (и тот факт, что это нативная Java), делает его практичным выбором для приложений, используемых "за корпоративным брандмауэром".

JavaFX, как и множество других UI фреймворков, может быстро стать громоздким и сложным в поддержке. К счастью, быстро-растущая платформа Kotlin дала возможность переосмыслить как разрабатываются JavaFX приложения.


# Why TornadoFX?

In February 2016, JetBrains released [Kotlin](http://kotlinlang.org), a new JVM language that emphasizes pragmatism over convention. Kotlin works at a higher level of abstraction and provides practical language features not available in Java. One of the more important features of Kotlin is its 100% interoperability with existing Java libraries and codebases, including JavaFX. Even more important is in 2017, Google backed Kotlin as an official language for Android. This gives Kotlin a bright future that has already extended beyond mobile apps. 

While JavaFX can be used with Kotlin in the same manner as Java, some believed Kotlin had language features that could streamline and simplify JavaFX development. Well before Kotlin's beta, Eugen Kiss prototyped JavaFX "builders" with KotlinFX. In January 2016, Edvin Syse rebooted the initiative and released TornadoFX.

TornadoFX seeks to greatly minimize the amount of code needed to build JavaFX applications. It not only includes type-safe builders to quickly lay out controls and user interfaces, but also features dependency injection, delegated properties, control extension functions, and other practical features enabled by Kotlin. TornadoFX is a fine showcase of how Kotlin can simplify codebases, and it tackles the verbosity of UI code with elegance and simplicity. It can work in conjunction with other popular JavaFX libraries such as [ControlsFX](http://fxexperience.com/controlsfx/) and [JFXtras](http://jfxtras.org/). It works especially well with reactive frameworks such as [ReactFX](https://github.com/TomasMikula/ReactFX) as well as [RxJava](https://github.com/ReactiveX/RxJava) and friends (including [RxJavaFX](https://github.com/ReactiveX/RxJavaFX), [RxKotlin](https://github.com/ReactiveX/RxKotlin), and [RxKotlinFX](https://github.com/thomasnield/RxKotlinFX)).

# Reader Requirements

This book expects readers to have some knowledge of Kotlin and have spent some time getting acquainted with it. There will be some coverage of Kotlin language features but only to a certain extent. If you have not done so already, read the [JetBrains Kotlin Reference](https://kotlinlang.org/docs/reference/) and spend a good few hours studying it.

It helps to be familiar with JavaFX but it is not a requirement. Many Kotlin developers reported using TornadoFX successfully without any JavaFX knowledge. What is particularly important to know about JavaFX is its concepts of `ObservableValue` and `Bindings`, which this guide will cover to a good degree. 

# A Motivational Example

If you have worked with JavaFX before, you might have created a `TableView` at some point. Say you have a given domain type `Person`. TornadoFX allows you to much more concisely create the JavaBeans-like convention used for the JavaFX binding.

```kotlin
class Person(id: Int, name: String, birthday: LocalDate) {
    val idProperty = SimpleIntegerProperty(id)
    var id by idProperty

    val nameProperty = SimpleStringProperty(name)
    var name by nameProperty

    val birthdayProperty = SimpleObjectProperty(birthday)
    var birthday by birthdayProperty

    val age: Int get() = Period.between(birthday, LocalDate.now()).years
}
```

You can then build an entire "`View`" containing a `TableView` with a small code footprint.

```kotlin
class MyView : View() {

    private val persons = listOf(
            Person(1, "Samantha Stuart", LocalDate.of(1981,12,4)),
            Person(2, "Tom Marks", LocalDate.of(2001,1,23)),
            Person(3, "Stuart Gills", LocalDate.of(1989,5,23)),
            Person(4, "Nicole Williams", LocalDate.of(1998,8,11))
    ).observable()

    override val root = tableview(persons) {
        column("ID", Person::idProperty)
        column("Name", Person::nameProperty)
        column("Birthday", Person::birthdayProperty)
        readonlyColumn("Age", Person::age)
    }
}
```

**RENDERED OUTPUT:**

![](https://camo.githubusercontent.com/21d91e000f36556b67bea322ff1152199aee483e/68747470733a2f2f692e696d6775722e636f6d2f41474d435038532e706e67)

Half of that code was just initializing sample data! If you hone in on just the part declaring the `TableView` with four columns (shown below), you will see it took a simple functional construct to build a `TableView`. It will automatically support edits to the fields as well.

```kotlin
tableview(persons) {
    column("ID", Person::idProperty)
    column("Name", Person::nameProperty)
    column("Birthday", Person::birthdayProperty)
    readonlyColumn("Age", Person::age)
}
```

As shown below, we can use the `cellFormat()` extension function on a `TableColumn`, and create conditional formatting for "Age" values that are less than `18`.

```kotlin
tableview<Person> {
    items = persons
    column("ID", Person::idProperty)
    column("Name", Person::nameProperty)
    column("Birthday", Person::birthdayProperty)
    readonlyColumn("Age", Person::age).cellFormat {
        text = it.toString()
        style {
            if (it < 18) {
                backgroundColor += c("#8b0000")
                textFill = Color.WHITE
            }
        }
    }
}
```

**RENDERED OUTPUT:**

![](https://camo.githubusercontent.com/dbc9a172be484e4ab8eeb0accc3799500e9fe791/68747470733a2f2f692e696d6775722e636f6d2f4d7932475545762e706e67)

These declarations are pure Kotlin code, and TornadoFX is packed with expressive power for dozens of cases like this. This allows you to focus on creating solutions rather than engineering UI code. Your JavaFX applications will not only be turned around more quickly, but also be maintainable and evolvable.
